revisão depois de 15 dias sem aula:
Projeto de banco de dados:
- Modelagem: elencar/identificar/destacar requisitos (estruturais e funcionais)
	- Modelagem Conceitual: entidade-relacionamento (ER)
		- entidade → tabela
		- atributos → variáveis
			- identificadores (chave-primária) → primary key
			- ordinários → não são identificadores
		- relacionamentos:
			- associação
			- herança
			- dependência
		- cardinalidade: 
			quantidade de um elemento de uma tabela que se relaciona com elementos de outra tabela.
			- **FUNDAMENTAL para definir chave-primária e chave-estrangeira (foreign-key)**:
				Tipos:
				- 1..1
				- 1..n → 1 .. *
				- n..n → * .. * 
			**interessante dar preferência para uma única chave-primária do que chaves compostas pois a verificação, a consulta, de uma única chave-primária é mais veloz que verificar duas, três, quatro...**
	- Modelagem Lógica
		transformação de entidade em tabela, pensando nas chaves-estrangeiras, saber fazer a chave-estrangeira pesando na cardinalidade é aumentar desempenho e otimizar disco
		- transformação de entidades em tabelas
		- definição de chaves estrangeiras a partir da cardinalidade
			- 1..1 - chave estrangeira pode estar em qualquer uma das entidades
			- 1..n - chave estrangeira vai para o lado do n que "puxa". 
				- exemplo: cabo de força, quem vence? 1 ou n. Um ou vários. Vários → n
			- n..n - cria-se uma terceira tabela, onde ambas chaves-primária vão se unir nessa nova tabela criada.
			O n "puxa" pra si sempre, no caso de muitos pra muitos (n..n) cria-se uma nova tabela
- Exemplo:
	- Conceitual: 
		- Pessoa(0..n) --- (1..n)Veiculo
	- Lógico:
		- Pessoa(codPessoa, nome, ..., CNH) 
		- Veiculo(codVeiculo, tipo, placa)
		- Locacao(codLocacao, codVeiculo, codPessoa, dataRetirada, dataDevolucao)
		A locação pelo livro indicado usaria agora codVeiculo e codPessoa como chave-primária, todavia em termos de desempenho é interessante usar uma única chave-primária, neste caso codLocacao.
		Porque? → é mais eficiente consultar apenas uma única chave primária do que duas ou mais.

notei que, para garantir eficiência é interessante reduzir ao máximo redundância das informações. 
também importante frizar que nem sempre reduzir ao máximo será a melhor estratégia. ChatGPT:
> Em um projeto de banco de dados, é fundamental reduzir ao máximo a **redundância de dados** para garantir eficiência, consistência e integridade das informações. Esse princípio é uma das bases da **normalização**
> No entanto, **nem sempre eliminar toda a redundância é a melhor estratégia**. Em alguns casos, uma **desnormalização controlada** pode ser usada para melhorar a performance, reduzindo o número de junções (joins) necessárias em consultas frequentes. Isso é comum em bancos de dados voltados para análises e Big Data.

MVP = Minumun Value Product

quando tu tem herança naturalmente tu faria uma tabela pra cada entidade, mas em computação menor é mais: quanto menos tabela menos busca que o sistema fará, então comprimisse tudo em uma única tabela (ou a menor quantidade possível, depende do contexto)
quando a linha x coluna não tem valor pois unificamos tudo em uma ficará armazenado NULL
NULL é muito interessante pois ocupa 0 bytes, ocupa nada, nadinha.
em contra-partida para a mineração o NULL é ruim, zamberlan tarado da mineração não recomenda o uso do NULL, mas é claro que depende do contexto

se tu programar algo no banco tu ta fudido caso tenho que trocar o banco, se fizer isso por fora facilita qualquer tipo de mudança que haja sob o banco de dados, mas claro, depende do contexto

DICAA!
- antes de modelar algo ENTENDA do que se trata para não sair modelando errado, vai ter que sentar a bunda e estudar o modelo de negócio da parada


